#!/usr/bin/env python3
"""Synchronize shared context into work repos."""
from __future__ import annotations

import argparse
import logging
import sys
from pathlib import Path

try:
    import yaml
except ImportError:
    print("pyyaml is required to run this script. Install it via 'pip install pyyaml' and retry.")
    sys.exit(1)

BASE_DIR = Path(__file__).resolve().parent

PROFILE_MAP = {
    "instructions": {
        "global": "instructions/00-global.md",
        "ds-dev": "instructions/10-ds-dev.md",
        "ds-prod": "instructions/10-ds-prod.md",
        "swe": "instructions/10-swe.md",
    },
    "business": {
        "biz-global": "business/00-biz-global.md",
        "biz-sales-forecasting": "business/10-biz-sales-forecasting.md",
    },
}

TARGET_FILES = {
    "instructions": "agents.md",
    "business": "business_context.md",
}

LOCAL_OVERRIDES = {
    "instructions": "agents.local.md",
    "business": "business_context.local.md",
}

DEFAULT_OVERRIDE_STUB = """# Repo-Specific Notes

There are no repo-specific notes yet.
"""

HEADER_TEMPLATE = (
    "<!-- AUTO-GENERATED ({namespace}). Do not edit this file directly.\n"
    "To change shared context, edit templates in this context-manager repo.\n"
    "To change repo-specific notes, edit {override_filename} in this repo.\n"
    "-->\n"
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Sync context templates into work repos.")
    parser.add_argument(
        "--repo",
        type=Path,
        help="Path to a single repo to sync. Overrides config/repos.yml when provided.",
    )
    return parser.parse_args()


def load_yaml_file(path: Path) -> dict:
    try:
        with path.open("r", encoding="utf-8") as handle:
            data = yaml.safe_load(handle) or {}
            if not isinstance(data, dict):
                raise ValueError("YAML root must be a mapping")
            return data
    except FileNotFoundError:
        raise
    except Exception as exc:  # pragma: no cover - runtime validation
        raise RuntimeError(f"Failed to parse YAML file {path}: {exc}") from exc


def read_context_profile(repo_path: Path) -> dict:
    profile_path = repo_path / ".context-profile.yml"
    if not profile_path.exists():
        raise FileNotFoundError(f"Missing .context-profile.yml in {repo_path}")
    data = load_yaml_file(profile_path)
    return data


def load_template(template_rel_path: str) -> str:
    template_path = BASE_DIR / template_rel_path
    if not template_path.exists():
        raise FileNotFoundError(f"Template not found: {template_path}")
    return template_path.read_text(encoding="utf-8").strip()


def build_sections(namespace: str, profile_names: list[str]) -> list[str]:
    sections = []
    for profile_name in profile_names:
        template_rel = PROFILE_MAP[namespace].get(profile_name)
        if not template_rel:
            raise KeyError(f"Unknown profile '{profile_name}' for namespace '{namespace}'")
        sections.append(load_template(template_rel))
    return sections


def append_override(repo_path: Path, namespace: str) -> str:
    override_filename = LOCAL_OVERRIDES.get(namespace)
    if not override_filename:
        return DEFAULT_OVERRIDE_STUB
    override_path = repo_path / override_filename
    if override_path.exists():
        return override_path.read_text(encoding="utf-8").strip()
    return DEFAULT_OVERRIDE_STUB


def write_namespace_file(repo_path: Path, namespace: str, sections: list[str]) -> None:
    target_filename = TARGET_FILES[namespace]
    override_filename = LOCAL_OVERRIDES.get(namespace, "repo override file")
    header = HEADER_TEMPLATE.format(namespace=namespace, override_filename=override_filename)
    override_content = append_override(repo_path, namespace)
    final_sections = sections + [override_content]
    output = header + "\n\n" + "\n\n---\n\n".join(final_sections) + "\n"
    target_path = repo_path / target_filename
    target_path.write_text(output, encoding="utf-8")
    logging.info("Wrote %s for namespace '%s'", target_path, namespace)


def validate_profiles(namespace: str, profiles: list) -> list[str]:
    if not isinstance(profiles, list) or not profiles:
        raise ValueError(f"Profiles for namespace '{namespace}' must be a non-empty list")
    normalized = []
    for profile in profiles:
        if not isinstance(profile, str):
            raise ValueError(
                f"Profile names for namespace '{namespace}' must be strings (got {profile!r})"
            )
        if profile not in PROFILE_MAP[namespace]:
            raise KeyError(f"Unknown profile '{profile}' for namespace '{namespace}'")
        normalized.append(profile)
    return normalized


def sync_repo(repo_path: Path) -> None:
    repo_path = repo_path.resolve()
    logging.info("Syncing repo: %s", repo_path)
    try:
        profile_config = read_context_profile(repo_path)
    except FileNotFoundError as exc:
        logging.error("%s", exc)
        return
    except RuntimeError as exc:
        logging.error("%s", exc)
        return

    for namespace in profile_config.keys():
        if namespace not in PROFILE_MAP:
            logging.error("Unknown namespace '%s' in %s", namespace, repo_path / ".context-profile.yml")

    for namespace in PROFILE_MAP:
        profiles = profile_config.get(namespace)
        if profiles is None:
            logging.warning("Namespace '%s' missing in %s; skipping", namespace, repo_path)
            continue
        try:
            normalized_profiles = validate_profiles(namespace, profiles)
            sections = build_sections(namespace, normalized_profiles)
            write_namespace_file(repo_path, namespace, sections)
        except (ValueError, KeyError, FileNotFoundError, RuntimeError) as exc:
            logging.error(
                "Failed to sync namespace '%s' for repo %s: %s", namespace, repo_path, exc
            )
            continue


def load_repos_from_config(config_path: Path) -> list[Path]:
    try:
        config = load_yaml_file(config_path)
    except FileNotFoundError:
        raise
    except RuntimeError as exc:
        raise RuntimeError(f"Failed to load repos config: {exc}") from exc

    repos_data = config.get("repos")
    if not isinstance(repos_data, list) or not repos_data:
        raise ValueError("config/repos.yml must define a non-empty 'repos' list")

    base_dir_value = config.get("base_dir")
    base_dir = Path(base_dir_value).expanduser() if base_dir_value else None

    repo_paths: list[Path] = []
    for repo_entry in repos_data:
        if isinstance(repo_entry, str):
            repo_path = Path(repo_entry)
        elif isinstance(repo_entry, dict):
            path_value = repo_entry.get("path") or repo_entry.get("name")
            if not path_value:
                logging.warning("Repo entry missing 'path' or 'name': %s", repo_entry)
                continue
            repo_path = Path(path_value)
        else:
            logging.warning("Skipping invalid repo entry: %s", repo_entry)
            continue
        if base_dir is not None:
            repo_path = (base_dir / repo_path).expanduser()
        else:
            repo_path = repo_path.expanduser()
            if not repo_path.is_absolute():
                logging.error("Repo path must be absolute when base_dir is not set: %s", repo_path)
                continue
        repo_path = repo_path.resolve()
        if not repo_path.exists():
            logging.warning("Repo path does not exist: %s", repo_path)
            continue
        if not repo_path.is_dir():
            logging.warning("Repo path is not a directory: %s", repo_path)
            continue
        repo_paths.append(repo_path)
    return repo_paths


def main() -> int:
    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
    args = parse_args()

    if args.repo:
        if not args.repo.exists() or not args.repo.is_dir():
            logging.error("Provided repo path is not a directory: %s", args.repo)
            return 1
        sync_repo(args.repo)
        return 0

    config_path = BASE_DIR / "config" / "repos.yml"
    if not config_path.exists():
        logging.error("config/repos.yml not found and no --repo provided. Nothing to do.")
        return 1

    try:
        repo_paths = load_repos_from_config(config_path)
    except (FileNotFoundError, ValueError, RuntimeError) as exc:
        logging.error("%s", exc)
        return 1

    if not repo_paths:
        logging.warning("No valid repos to sync.")
        return 0

    for repo_path in repo_paths:
        sync_repo(repo_path)
    return 0


if __name__ == "__main__":
    sys.exit(main())
